G4VParticleChange* nbDriftPhysics::AlongStepDoIt(const G4Track& aTrack, const G4Step& aStep)
{
   // we need to push the particle in upward direction here
   
   aParticleChange.Initialize(aTrack);   // this is from official source of G4VParticleChange OR G4VContinuousProcess
   
   // // get current velocity in this step 
   // 
   // G4double currentVelocity = aStep.GetPostStepPoint()->GetVelocity();
   // 
   // G4cout << "current velocity is = " << currentVelocity * mm/s << "mm/s" << G4endl;
   // 
   // G4double updatedVelocity = currentVelocity + 100 * m/s;
   // 
   // G4cout << "updated velocity is = " << updatedVelocity * mm/s  << "mm/s" << G4endl;
   // 
   // // propose this velocity
   // 
   // aParticleChange.ProposeVelocity(updatedVelocity);
   // 
   // auto dir = aStep.GetPostStepPoint()->GetMomentumDirection();
   // 
   // // G4ThreeVector tempMomentumDirection = new G4ThreeVector(0., 1., 0.);
   // // momentumDirection = momentumDirection + tempMomentum;
   // 
   // aParticleChange.ProposeMomentumDirection(G4ThreeVector(0., 1., 0.));
   
   // get current velocity in this step 
   
   G4double currentKE = aStep.GetPostStepPoint()->GetKineticEnergy();
   
   G4cout << "current velocity is = " << currentKE << G4endl;
   
   G4double newKE = currentKE + 100. *MeV;
   
   G4cout << "updated velocity is = " << newKE << G4endl;
   
   // propose this velocity
   
   aParticleChange.ProposeEnergy(newKE);
   
   auto dir = aStep.GetPostStepPoint()->GetMomentumDirection();
   
   // G4ThreeVector tempMomentumDirection = new G4ThreeVector(0., 1., 0.);
   // momentumDirection = momentumDirection + tempMomentum;
   
   aParticleChange.ProposeMomentumDirection(G4ThreeVector(0., 1., 0.));
   
      
   return &aParticleChange;
}
